<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Live Sonar Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#000; color:#0f0; font-family: Inter, Roboto, monospace; }
    #ui { position:fixed; left:10px; top:10px; color:#0f0; font-size:14px; z-index:3; }
    #cwrap { display:flex; align-items:center; justify-content:center; height:100vh; }
    canvas { background:transparent; max-width:100%; height:auto; display:block; }
    .badge { background: rgba(0,0,0,0.6); padding:6px 8px; border-radius:6px; border:1px solid rgba(0,255,0,0.12); }
    #legend { position:fixed; right:10px; top:10px; color:#0f0; font-size:13px; }
  </style>
</head>
<body>
  <div id="ui" class="badge">Status: <span id="status">disconnected</span> &nbsp; | &nbsp; Range: <span id="range">â€”</span> m</div>
  <div id="legend" class="badge">Red = detection / pulse = sudden change</div>
  <div id="cwrap">
    <canvas id="c" width="1000" height="700"></canvas>
  </div>

<script>
const SERVER = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/viewer';
const MAX_RANGE_M = 6.0;
const ARC_COUNT = 6;
const OUTER_MARGIN = 0.85;
const SUDDEN_CHANGE_THRESHOLD_M = 0.35;
const DETECTION_FADE_MS = 2000;
const PULSE_DURATION_MS = 1200;
const KEEP_HISTORY = 20;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const statusSpan = document.getElementById('status');
const rangeSpan = document.getElementById('range');

let ws = null;
let lastDistance = null;
let detections = [];
let wsConnected = false;

function nowMs(){ return Date.now(); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function drawBackground(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cx = canvas.width/2;
  const cy = canvas.height * 0.18;
  const halfWidth = canvas.width * 0.5;
  const maxRadiusPx = halfWidth * OUTER_MARGIN;

  ctx.beginPath();
  ctx.fillStyle = "#0f0";
  ctx.arc(cx, cy, 4, 0, Math.PI*2);
  ctx.fill();

  for(let i=ARC_COUNT; i>=1; --i){
    const t = i / ARC_COUNT;
    const r = t * maxRadiusPx;
    ctx.beginPath();
    ctx.lineWidth = 3;
    const alpha = 0.14 + 0.5*(t*0.7);
    ctx.strokeStyle = `rgba(0,255,0,${alpha})`;
    ctx.arc(cx, cy, r, 0, Math.PI);
    ctx.stroke();

    if(i === ARC_COUNT){
      const g = ctx.createRadialGradient(cx, cy, 10, cx, cy + r, r);
      g.addColorStop(0, "rgba(0,255,0,0.06)");
      g.addColorStop(1, "rgba(0,0,0,0.0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI);
      ctx.lineTo(cx, cy);
      ctx.closePath();
      ctx.fill();
    }
  }

  ctx.fillStyle = "#0f0";
  ctx.font = "13px monospace";
  ctx.textAlign = "center";
  for(let i=1;i<=ARC_COUNT;i++){
    const t = i / ARC_COUNT;
    const r = t * maxRadiusPx;
    const dist = (t * MAX_RANGE_M).toFixed(2);
    ctx.fillText(`${dist} m`, cx, cy + r + 16);
  }

  return {cx,cy,maxRadiusPx};
}

function render(){
  const {cx,cy,maxRadiusPx} = drawBackground();
  const now = nowMs();
  for(let i=0;i<detections.length;i++){
    const d = detections[i];
    const age = now - d.timestamp;
    if(age > DETECTION_FADE_MS + PULSE_DURATION_MS) continue;
    const fade = 1 - clamp(age / (DETECTION_FADE_MS + PULSE_DURATION_MS), 0, 1);
    if(d.type === 'pulse'){
      const t = clamp((now - d.timestamp) / PULSE_DURATION_MS, 0, 1);
      const pulseR = (1 + 0.5 * t) * (d.radius_px || 6);
      ctx.beginPath();
      ctx.lineWidth = 3 + 3*(1 - t);
      ctx.strokeStyle = `rgba(255,0,0,${0.9 * fade})`;
      ctx.arc(d.x, d.y, pulseR, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,0,0,${0.95 * fade})`;
      ctx.arc(d.x, d.y, 6, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,0,0,${0.95 * fade})`;
      ctx.arc(d.x, d.y, 5, 0, Math.PI*2);
      ctx.fill();
    }
  }
  requestAnimationFrame(render);
}

function distanceToRadiusPx(distance_m, maxRadiusPx){
  const frac = clamp(distance_m / MAX_RANGE_M, 0, 1);
  return frac * maxRadiusPx;
}

function polarToCanvas(cx, cy, radius_px, angle_deg){
  const angle_rad = (Math.PI/2) + (angle_deg * Math.PI/180.0);
  const x = cx + radius_px * Math.cos(angle_rad);
  const y = cy + radius_px * Math.sin(angle_rad);
  return {x,y};
}

function handlePayload(payload){
  try {
    const distance_m = (payload.distance_m === null || payload.distance_m === undefined) ? null : Number(payload.distance_m);
    const angle_deg = (payload.angle_deg === undefined || payload.angle_deg === null) ? 0 : Number(payload.angle_deg);
    const ts = payload.timestamp ? Date.parse(payload.timestamp) : nowMs();
    rangeSpan.textContent = MAX_RANGE_M.toFixed(2);
    const {cx,cy,maxRadiusPx} = drawBackground();
    if(distance_m !== null){
      const radius_px = distanceToRadiusPx(distance_m, maxRadiusPx);
      const pos = polarToCanvas(cx, cy, radius_px, angle_deg);
      let isPulse = false;
      if(lastDistance !== null){
        const delta = Math.abs(distance_m - lastDistance);
        if(delta >= SUDDEN_CHANGE_THRESHOLD_M){
          isPulse = true;
        }
      }
      lastDistance = distance_m;
      detections.push({x:pos.x,y:pos.y,radius_px,distance_m,angle_deg,timestamp:nowMs(),type:isPulse?'pulse':'normal'});
      if(detections.length > KEEP_HISTORY) detections.shift();
    } else {
      lastDistance = null;
      const pos = polarToCanvas(cx, cy, maxRadiusPx, 0);
      detections.push({x:pos.x,y:pos.y,distance_m:null,timestamp:nowMs(),type:'pulse',radius_px:10});
      if(detections.length > KEEP_HISTORY) detections.shift();
    }
  } catch(e){
    console.error("Bad payload:", e, payload);
  }
}

function connectWS(){
  try { ws = new WebSocket(SERVER); } catch(e){ statusSpan.textContent = "error"; setTimeout(connectWS, 3000); return; }

  ws.onopen = () => { wsConnected=true; statusSpan.textContent="connected"; setInterval(()=>{ try{ ws.send('ping'); }catch{} },20000); };
  ws.onmessage = (ev) => { try{ handlePayload(JSON.parse(ev.data)); }catch{} };
  ws.onclose = () => { wsConnected=false; statusSpan.textContent="disconnected"; setTimeout(connectWS,2000); };
  ws.onerror = (e) => { wsConnected=false; statusSpan.textContent="error"; ws.close(); };
}

function resizeCanvas(){
  const parent = canvas.parentElement;
  const w = Math.min(window.innerWidth*0.98,1200);
  const h = Math.min(window.innerHeight*0.9,900);
  canvas.width = Math.round(w);
  canvas.height = Math.round(h);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();
render();
connectWS();

</script>
</body>
</html>
